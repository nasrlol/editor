platform
    - resizing & (wrapping)
- fix keyboard input (pressing & holding, vs text)
    - shift should not be a modifier.
    - loop editing


    =====================================================================

    parser notes: (extracted notes to clean up file)

    /**
     * NOTE(nasr): what are the steps we have to follow?
     * we take in the complete file buffer?
     * but should it be the the complete file?
     * what if we have multiple files?
     *
     * what we could do is have a initial complete lexical analysis of
     * all source files, and build a concrete syntax tree, not an ast, but a concrete syntax tree
     *
     * and on a file save or change try to update the concrete syntax tree
     *  but it would be nice if the concrete syntax tree could change without needing to have to
     *  save the file after each edit or change
     *
     *  but doing that would mean that we need to have a LSP server that does a continous analysis
     *
     **/

    /**
     * NOTE(nasr): what im trying to do here is do a regular parsing scan over the
     * complete buffer, seperate words on spaces and other general delimters
     * and get a list of tokens out of this so i can run the tokenizer of a list
     * */

    /**
     * NOTE(nasr): new idea, make a parse -> lexing pipeline
     * we make continous parsing for the continous input
     * and then we do a search on the nodes of the cst
     **/

    /*
     * Lets say we have a line \\ int main() { return 0; }
     * this line shows that a function has a return type, a name, braces
     * and the scope of the function starts end ends with braces { }
     * so the tree should shows
     * [function(main(return type)(name)(parameters))[scope[and here have more stuff]]]
     * now the tricky part about c is that most things are seperated by spaces but not all
     * T value = {0}; \\ this for example is allowed.
     **/

    /*
     * TODO(nasr): think about the new lines,
     * a new line doesnt define a new branch or scope of syntax
     * but it is often used?
     *
     * do we handle it or not?
     * */
    /**
     * I think i misunderstood the difference between a parser and a parser
     **/


    // NOTE(nasr): skip whitespace but track position
    //
    // NOTE(nasr): check if current char is a delimiter
    // NOTE(nasr): scan until we hit whitespace or delimiter while(TextIndex < app->TextCount)
    /*
     * TODO(nasr): how do we handle unary expressions?
     * */

    /*
     * for preprocessor stuff
     * #include #endif
     * */

    // NOTE(nasr): check if it's a number literal
    // NOTE(nasr): check if it's a string literal
    /* TODO(nasr): what are the possible identifier starters? */

    // NOTE(nasr): check for keywords
    /**
     * NOTE(nasr): check for single-character tokens
     * TODO(nasr): after talking with luca about parser design
     * we will need to add white space accounting and more positioning information
     **/

    // NOTE(nasr): if nothing else, it's probably an identifier
    //
    /**
     * NOTE(nasr): The tokenize function takes the parsed buffer and tokenizes
     * every element in the list
     * We try to identify the leximes, that were previously split up;
     * */


    /*
     * NOTE(nasr):
     * lets say we have a set of tokens
     * [[int][main][(][int][argc]][)][{][}]]
     * how do we build a tree out of this?
     * */

    /* NOTE(nasr): building the concretee syntax tree */

    /**
     * What defines the root of a concrete syntax tree
     * when do branches get created?
     * not at the start of a line because this is possible ->
     * \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     * internal int
     * main(int argc, char **argv)
     * { retur 0; }
     * \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
     **/

    /* NOTE(nasr): we know that a semicolon defines the end of of a branch */

    /**
     * check if a token is a sort of token
     * does that token take children or something else
     **/

    /**
     * TODO(nasr):
     * 1. find the node
     * 2. remove the node
     * 3. restructure the thing
     * **/

    /**
     *
     * NOTE(nasr): following the conversation with luca
     * about having 2 parsers what popped out was that
     * it's important to differentiate between assignments and
     * declarations is a must. So will try to check for what
     **/


    /* NOTE(nasr): max children we can hold
     * (not sure if this something we should account for?
     * couldnt we work with checking the arena size
     * and resizing that one instead of keeping trakc of the tree size?)
     *
     * at the same time it's also something to consider because it allows us to have
     * a more defined control over the amount of nodes within a cst
     *
     * NOTE(nasr): nevermind i think it's usefull to have it because it's something
     * per node, so per branch, and if a large branch get's deleted we could do
     * a proper deletion of that entire branch which improves refactoring capabilities
     */

    /**
     * NOTE(nasr): source location tracking for go-to-definition
     * https://github.com/jqcorreia/lang/blob/main/lexer.odin
     * l54
     *
     **/

    /*
     * NOTE(nasr): refactored the concrete syntax tree because the actual
     * tree struct doesnt need to know information about the actual tree
     * that information is contained within the struct
     * */

    /**
     * NOTE(nasr): ** we should track the location of each node of the syntax tree
     * in a file so that go to definitions are possible
     * ** requires having a map of all files in the project?
     * wouldnt this take lots of space?
     * !! NO more like have something that maps the translation unit(s)
     * and works on that?
     **/

    /*
     * TODO(nasr): replace with byte offsets
     * */
    // NOTE(nasr): linked list of tokens for efficient traversal
